---
title: "Build Model"
date: "`r Sys.time()`"
output: html_document
---

```{r}
library(dplyr)
library(glue)
library(recipes)
library(parsnip)
library(workflows)
library(vetiver)

# Internally developed packages
library(bikeHelpR)
```

# Get data

Connect to the database:

```{r}
con <- DBI::dbConnect(odbc::odbc(), "Content DB")
```

Split the data into a train/test split:

```{r}
all_days <- tbl(con, "bike_model_data")

# Get a vector that contains all of the dates.
dates <- all_days %>%
  distinct(date) %>%
  collect() %>%
  arrange(desc(date)) %>%
  pull(date) %>%
  as.Date()

# Split the data into test and train.
n_days_test <- 2
n_days_to_train <- 10
train_end_date <- dates[n_days_test + 1]
train_start_date <- train_end_date - n_days_to_train

# Training data split.
train_data <- all_days %>%
  filter(
    date >= train_start_date,
    date <= train_end_date
  ) %>%
  distinct() %>%
  collect()

print(glue::glue(
  "The model will be trained on data from {start} to {end} ",
  "({num_obs} observations). ",
  start = min(train_data$date),
  end = max(train_data$date),
  num_obs = scales::comma(nrow(train_data)),
))

# Test data split.
test_data <- all_days %>%
  filter(date > train_end_date) %>%
  distinct() %>%
  collect()

print(glue::glue(
  "The model will be tested on data from {start} to {end} ",
  "({num_obs} observations). ",
  start = min(test_data$date),
  end = max(test_data$date),
  num_obs = scales::comma(nrow(test_data)),
))
```

# Train the model

## Data preprocessing

Define a recipe to clean the data.

```{r}
# Define a recipe to clean the data.
recipe_spec <- 
  recipe(n_bikes ~ ., data = train_data) %>% 
  step_dummy(dow) %>%
  step_integer(id, date)

recipe_spec_prepped <- prep(recipe_spec, train_data)

# Preview the cleaned training data.
bake(recipe_spec_prepped, head(train_data))
```

## Fit model

Fit a random forest model:

```{r}
# workflow
model_spec <- rand_forest(trees = 200) %>%
  set_mode("regression") %>%
  set_engine("ranger")

model_workflow <- 
  workflow() %>%
  add_recipe(recipe_spec) %>%
  add_model(model_spec)

model_fit <- fit(model_workflow, data = train_data)
model_fit
```

# Model evaluation

```{r evaluate_model}
predictions <- predict(model_fit, test_data)

results <- test_data %>%
  mutate(preds = predictions$.pred)

oos_metrics(results$n_bikes, results$preds)
```

# Model deployment

## `vetiver`

Create a `vetiver` model object.

```{r create_vetiver_model}
model_name <- "bike_predict_model_r"

v <- vetiver_model(
  model_fit, 
  model_name,
  versioned = TRUE,
  save_ptype = train_data %>%
    head(1) %>%
    select(-n_bikes)
)

v
```

## `pins`

Save the model as a *pin* to RStudio Connect:

```{r pin_model}
# Use RStudio Connect as a board.
board <- pins::board_rsconnect(
  server = Sys.getenv("CONNECT_SERVER"),
  key = Sys.getenv("CONNECT_API_KEY"),
  versioned = TRUE
)

# Write the model to the board.
board %>%
 vetiver_pin_write(v)
```

Check out the version history of the model:

```{r}
pin_name <- glue("sam.edwardes/{model_name}")
print(glue("Connect to pin named: {pin_name}"))

board %>% 
  pins::pin_versions(pin_name)
```

## `plumber`

Convert the model into a plumber API. The function `vetiver_write_plumber` will generate the plumber code for you and write it to *plumber.R*.

```{r deploy_model}
# Write the model to `api/plumber.R`.
vetiver_write_plumber(board, pin_name, file = "api/plumber.R")

# Write a manifest.json file for the api
rsconnect::writeManifest("api")
```

Here is what the plumber file looks like:

```{r preview_plumber_file}
readLines("api/plumber.R") %>%
  paste(collapse = "\n") %>%
  cat()
```

## RStudio Connect

Then, deploy the plumber API to RStudio Connect.

```{r}
app_name <- "bike-predict-api-r"
app_title <- "Bike Predict API (R)"

# Establish a connectionn to RStudio connect.
client <- connectapi::connect(
  server = Sys.getenv("CONNECT_SERVER"),
  api_key = Sys.getenv("CONNECT_API_KEY")
)

tags <- client %>%
  connectapi::get_tags()

# Deploy the content.
content <- 
  client %>%
  connectapi::deploy(
    connectapi::bundle_dir("api"),
    name = app_name,
    title = app_title
  )

# Make the app visible to the world!
content$update(access_type = "all")

client %>% 
  connectapi::get_groups(page_size = 500, limit = 500) %>%
  filter("sol" %in% tolower(name))

# Define the contents collaborators
collaborators <- c(
  # "d03a6b7a-c818-4e40-8ef9-84ca567f9671", # Sam Edwardes
  "69db516b-ba3e-442a-84d9-f916fc92a2ca", # Gagan Singh
  "99a43fac-2edd-4c31-8cba-a001c507da2e"  # Xu Fei
  
)
for (c in collaborators) {
  content %>%
    connectapi::acl_add_collaborator(c)
}

# Update content settings.
content %>%
  connectapi::set_vanity_url("bike-predict-api-r") %>%
  connectapi::set_content_tags(tags$`Projects and Presentations`$`Bike Predict`$R) %>%
  connectapi::set_image_path("../../../img/bike_share_connect_image.drawio.png") %>%
  connectapi::add
```

Called the deployed API to verify that it is working.

```{r}
url <- glue("{content$get_url()}predict")
endpoint <- vetiver_endpoint(url)
endpoint
```

```{r}
predict(endpoint, head(test_data, 2)) %>%
  bind_cols(head(test_data, 2))
```

```{r}
DBI::dbDisconnect(con)
```
